-- Generated using RoadToGlory's Converter v1.1 (RoadToGlory#9879)

-- Instances:

local Converted = {
	["_ScreenGui"] = Instance.new("ScreenGui");
	["_launcher"] = Instance.new("Frame");
	["_TextLabel"] = Instance.new("TextLabel");
	["_UICorner"] = Instance.new("UICorner");
	["_TextLabel1"] = Instance.new("TextLabel");
	["_xapitext"] = Instance.new("TextLabel");
	["_xcmdtext"] = Instance.new("TextLabel");
	["_TextButton"] = Instance.new("TextButton");
	["_LocalScript"] = Instance.new("LocalScript");
	["_wait"] = Instance.new("LocalScript");
	["_LocalScript1"] = Instance.new("LocalScript");
	["_UICorner1"] = Instance.new("UICorner");
	["_popup"] = Instance.new("Frame");
	["_TextLabel2"] = Instance.new("TextLabel");
	["_popuptext"] = Instance.new("TextLabel");
	["_LocalScript2"] = Instance.new("LocalScript");
	["_UICorner2"] = Instance.new("UICorner");
	["_datac1"] = Instance.new("Frame");
	["_Frame"] = Instance.new("Frame");
	["_Frame1"] = Instance.new("Frame");
	["_TextButton1"] = Instance.new("TextButton");
	["_Frame2"] = Instance.new("Frame");
	["_ScrollingFrame"] = Instance.new("ScrollingFrame");
	["_ezhub"] = Instance.new("TextButton");
	["_LocalScript3"] = Instance.new("LocalScript");
	["_archiveadminhub"] = Instance.new("TextButton");
	["_LocalScript4"] = Instance.new("LocalScript");
	["_dex"] = Instance.new("TextButton");
	["_LocalScript5"] = Instance.new("LocalScript");
	["_yeild"] = Instance.new("TextButton");
	["_LocalScript6"] = Instance.new("LocalScript");
	["_TextLabel3"] = Instance.new("TextLabel");
	["_UICorner3"] = Instance.new("UICorner");
	["_TextLabel4"] = Instance.new("TextLabel");
	["_UICorner4"] = Instance.new("UICorner");
	["_Frame3"] = Instance.new("Frame");
	["_WalkSpeed"] = Instance.new("Folder");
	["_speedon"] = Instance.new("TextButton");
	["_TextLabel5"] = Instance.new("TextLabel");
	["_speed"] = Instance.new("TextBox");
	["_LocalScript7"] = Instance.new("LocalScript");
	["_Value"] = Instance.new("NumberValue");
	["_JumpPower"] = Instance.new("Folder");
	["_jumpon"] = Instance.new("TextButton");
	["_TextLabel6"] = Instance.new("TextLabel");
	["_jump"] = Instance.new("TextBox");
	["_LocalScript8"] = Instance.new("LocalScript");
	["_Air Stuck"] = Instance.new("Folder");
	["_speedon1"] = Instance.new("TextButton");
	["_LocalScript9"] = Instance.new("LocalScript");
	["_Value1"] = Instance.new("NumberValue");
	["_TextLabel7"] = Instance.new("TextLabel");
	["_Fly"] = Instance.new("Folder");
	["_jumpon1"] = Instance.new("TextButton");
	["_LocalScript10"] = Instance.new("LocalScript");
	["_TextLabel8"] = Instance.new("TextLabel");
	["_Fake Lag"] = Instance.new("Folder");
	["_jumpon2"] = Instance.new("TextButton");
	["_LocalScript11"] = Instance.new("LocalScript");
	["_TextLabel9"] = Instance.new("TextLabel");
	["_TextLabel10"] = Instance.new("TextLabel");
	["_TextButton2"] = Instance.new("TextButton");
	["_LocalScript12"] = Instance.new("LocalScript");
	["_uncchecker"] = Instance.new("Frame");
	["_green"] = Instance.new("TextLabel");
	["_red"] = Instance.new("TextLabel");
	["_yellow"] = Instance.new("TextLabel");
	["_TextLabel11"] = Instance.new("TextLabel");
	["_LocalScript13"] = Instance.new("LocalScript");
	["_LocalScript14"] = Instance.new("LocalScript");
	["_UICorner5"] = Instance.new("UICorner");
}

-- Properties:

Converted["_ScreenGui"].ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Converted["_ScreenGui"].Parent = game:GetService("CoreGui")

Converted["_launcher"].BackgroundColor3 = Color3.fromRGB(81.00000277161598, 0, 255)
Converted["_launcher"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_launcher"].BorderSizePixel = 0
Converted["_launcher"].Position = UDim2.new(0.364636838, 0, 0.203980103, 0)
Converted["_launcher"].Size = UDim2.new(0, 383, 0, 507)
Converted["_launcher"].Name = "launcher"
Converted["_launcher"].Parent = Converted["_ScreenGui"]

Converted["_TextLabel"].Font = Enum.Font.SourceSans
Converted["_TextLabel"].Text = "Xeon/XExploit Launcher"
Converted["_TextLabel"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel"].TextScaled = true
Converted["_TextLabel"].TextSize = 14
Converted["_TextLabel"].TextWrapped = true
Converted["_TextLabel"].BackgroundColor3 = Color3.fromRGB(5.000000176951289, 5.000000176951289, 255)
Converted["_TextLabel"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel"].BorderSizePixel = 0
Converted["_TextLabel"].Size = UDim2.new(0, 383, 0, 50)
Converted["_TextLabel"].Parent = Converted["_launcher"]

Converted["_UICorner"].CornerRadius = UDim.new(0.100000001, 8)
Converted["_UICorner"].Parent = Converted["_TextLabel"]

Converted["_TextLabel1"].Font = Enum.Font.SourceSans
Converted["_TextLabel1"].Text = "VER: 1.1"
Converted["_TextLabel1"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel1"].TextScaled = true
Converted["_TextLabel1"].TextSize = 14
Converted["_TextLabel1"].TextWrapped = true
Converted["_TextLabel1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel1"].BackgroundTransparency = 0.5
Converted["_TextLabel1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel1"].BorderSizePixel = 0
Converted["_TextLabel1"].Position = UDim2.new(0, 0, 0.218934909, 0)
Converted["_TextLabel1"].Size = UDim2.new(0, 383, 0, 50)
Converted["_TextLabel1"].Parent = Converted["_launcher"]

Converted["_xapitext"].Font = Enum.Font.SourceSans
Converted["_xapitext"].Text = "XAPI: OK"
Converted["_xapitext"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_xapitext"].TextScaled = true
Converted["_xapitext"].TextSize = 14
Converted["_xapitext"].TextWrapped = true
Converted["_xapitext"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_xapitext"].BackgroundTransparency = 0.5
Converted["_xapitext"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_xapitext"].BorderSizePixel = 0
Converted["_xapitext"].Position = UDim2.new(0, 0, 0.337278098, 0)
Converted["_xapitext"].Size = UDim2.new(0, 383, 0, 50)
Converted["_xapitext"].Name = "xapitext"
Converted["_xapitext"].Parent = Converted["_launcher"]

Converted["_xcmdtext"].Font = Enum.Font.SourceSans
Converted["_xcmdtext"].Text = "XLAUNCHER: OK"
Converted["_xcmdtext"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_xcmdtext"].TextScaled = true
Converted["_xcmdtext"].TextSize = 14
Converted["_xcmdtext"].TextWrapped = true
Converted["_xcmdtext"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_xcmdtext"].BackgroundTransparency = 0.5
Converted["_xcmdtext"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_xcmdtext"].BorderSizePixel = 0
Converted["_xcmdtext"].Position = UDim2.new(0, 0, 0.44970414, 0)
Converted["_xcmdtext"].Size = UDim2.new(0, 383, 0, 50)
Converted["_xcmdtext"].Name = "xcmdtext"
Converted["_xcmdtext"].Parent = Converted["_launcher"]

Converted["_TextButton"].Font = Enum.Font.SourceSans
Converted["_TextButton"].Text = "Load Xeon"
Converted["_TextButton"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextButton"].TextScaled = true
Converted["_TextButton"].TextSize = 14
Converted["_TextButton"].TextWrapped = true
Converted["_TextButton"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextButton"].BackgroundTransparency = 0.5
Converted["_TextButton"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextButton"].BorderSizePixel = 0
Converted["_TextButton"].Position = UDim2.new(0.219321147, 0, 0.824457586, 0)
Converted["_TextButton"].Size = UDim2.new(0, 200, 0, 50)
Converted["_TextButton"].Parent = Converted["_launcher"]

Converted["_UICorner1"].CornerRadius = UDim.new(0.100000001, 8)
Converted["_UICorner1"].Parent = Converted["_launcher"]

Converted["_popup"].BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Converted["_popup"].BackgroundTransparency = 0.5
Converted["_popup"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_popup"].BorderSizePixel = 0
Converted["_popup"].Position = UDim2.new(0.0102714598, 0, 0.798507452, 0)
Converted["_popup"].Size = UDim2.new(0, 275, 0, 129)
Converted["_popup"].Visible = false
Converted["_popup"].Name = "popup"
Converted["_popup"].Parent = Converted["_ScreenGui"]

Converted["_TextLabel2"].Font = Enum.Font.SourceSans
Converted["_TextLabel2"].Text = "Info"
Converted["_TextLabel2"].TextColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel2"].TextScaled = true
Converted["_TextLabel2"].TextSize = 14
Converted["_TextLabel2"].TextWrapped = true
Converted["_TextLabel2"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel2"].BackgroundTransparency = 1
Converted["_TextLabel2"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel2"].BorderSizePixel = 0
Converted["_TextLabel2"].Size = UDim2.new(0, 275, 0, 25)
Converted["_TextLabel2"].Parent = Converted["_popup"]

Converted["_popuptext"].Font = Enum.Font.SourceSans
Converted["_popuptext"].Text = "Welcome"
Converted["_popuptext"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_popuptext"].TextScaled = true
Converted["_popuptext"].TextSize = 14
Converted["_popuptext"].TextWrapped = true
Converted["_popuptext"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_popuptext"].BackgroundTransparency = 0.5
Converted["_popuptext"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_popuptext"].BorderSizePixel = 0
Converted["_popuptext"].Position = UDim2.new(0, 0, 0.350000203, 0)
Converted["_popuptext"].Size = UDim2.new(0, 275, 0, 50)
Converted["_popuptext"].Name = "popuptext"
Converted["_popuptext"].Parent = Converted["_popup"]

Converted["_UICorner2"].CornerRadius = UDim.new(0.100000001, 8)
Converted["_UICorner2"].Parent = Converted["_popup"]

Converted["_datac1"].BackgroundColor3 = Color3.fromRGB(32.00000189244747, 121.0000079870224, 255)
Converted["_datac1"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_datac1"].Position = UDim2.new(0.151137203, 0, 0.0373134315, 0)
Converted["_datac1"].Size = UDim2.new(0, 951, 0, 669)
Converted["_datac1"].Visible = false
Converted["_datac1"].Name = "datac1"
Converted["_datac1"].Parent = Converted["_ScreenGui"]

Converted["_Frame"].BackgroundColor3 = Color3.fromRGB(169.00000512599945, 148.000006377697, 255)
Converted["_Frame"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_Frame"].Position = UDim2.new(0.500109613, 0, 0.168439507, 0)
Converted["_Frame"].Size = UDim2.new(0, 610, 0, 425)
Converted["_Frame"].Parent = Converted["_datac1"]

Converted["_Frame1"].BackgroundColor3 = Color3.fromRGB(42.000001296401024, 35.00000171363354, 255)
Converted["_Frame1"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_Frame1"].Position = UDim2.new(-1, 0, 0, 0)
Converted["_Frame1"].Size = UDim2.new(0, 610, 0, 425)
Converted["_Frame1"].Parent = Converted["_Frame"]

Converted["_TextButton1"].Font = Enum.Font.SourceSans
Converted["_TextButton1"].Text = "Soon"
Converted["_TextButton1"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextButton1"].TextSize = 54
Converted["_TextButton1"].BackgroundColor3 = Color3.fromRGB(17.00000088661909, 231.0000166296959, 255)
Converted["_TextButton1"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_TextButton1"].Position = UDim2.new(0.652459025, 0, 0.802352965, 0)
Converted["_TextButton1"].Size = UDim2.new(0, 200, 0, 50)
Converted["_TextButton1"].Parent = Converted["_Frame1"]

Converted["_Frame2"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_Frame2"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_Frame2"].Position = UDim2.new(0.021311475, 0, 0.223529413, 0)
Converted["_Frame2"].Size = UDim2.new(0, 366, 0, 296)
Converted["_Frame2"].Parent = Converted["_Frame1"]

Converted["_ScrollingFrame"].ScrollBarImageColor3 = Color3.fromRGB(0, 0, 0)
Converted["_ScrollingFrame"].Active = true
Converted["_ScrollingFrame"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_ScrollingFrame"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_ScrollingFrame"].BorderSizePixel = 0
Converted["_ScrollingFrame"].Position = UDim2.new(0.0153004797, 0, -0.00474568969, 0)
Converted["_ScrollingFrame"].Size = UDim2.new(0, 360, 0, 297)
Converted["_ScrollingFrame"].Parent = Converted["_Frame2"]

Converted["_ezhub"].Font = Enum.Font.SourceSans
Converted["_ezhub"].Text = " EzHub (CAN CRASH!)"
Converted["_ezhub"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_ezhub"].TextSize = 44
Converted["_ezhub"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_ezhub"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_ezhub"].Position = UDim2.new(-0.00887976773, 0, 0.00386617635, 0)
Converted["_ezhub"].Size = UDim2.new(0, 366, 0, 50)
Converted["_ezhub"].Name = "ezhub"
Converted["_ezhub"].Parent = Converted["_ScrollingFrame"]

Converted["_archiveadminhub"].Font = Enum.Font.SourceSans
Converted["_archiveadminhub"].Text = "Universal ESP"
Converted["_archiveadminhub"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_archiveadminhub"].TextScaled = true
Converted["_archiveadminhub"].TextSize = 44
Converted["_archiveadminhub"].TextWrapped = true
Converted["_archiveadminhub"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_archiveadminhub"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_archiveadminhub"].Position = UDim2.new(-0.0172129311, 0, 0.0862469897, 0)
Converted["_archiveadminhub"].Size = UDim2.new(0, 366, 0, 50)
Converted["_archiveadminhub"].Name = "archiveadminhub"
Converted["_archiveadminhub"].Parent = Converted["_ScrollingFrame"]

Converted["_dex"].Font = Enum.Font.SourceSans
Converted["_dex"].Text = "DEX"
Converted["_dex"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_dex"].TextScaled = true
Converted["_dex"].TextSize = 14
Converted["_dex"].TextWrapped = true
Converted["_dex"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_dex"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_dex"].BorderSizePixel = 0
Converted["_dex"].Position = UDim2.new(-0.0194444451, 0, 0.173743039, 0)
Converted["_dex"].Size = UDim2.new(0, 363, 0, 50)
Converted["_dex"].Name = "dex"
Converted["_dex"].Parent = Converted["_ScrollingFrame"]

Converted["_yeild"].Font = Enum.Font.SourceSans
Converted["_yeild"].Text = "Infinite Yield"
Converted["_yeild"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_yeild"].TextScaled = true
Converted["_yeild"].TextSize = 14
Converted["_yeild"].TextWrapped = true
Converted["_yeild"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_yeild"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_yeild"].BorderSizePixel = 0
Converted["_yeild"].Position = UDim2.new(0.00833333377, 0, 0.2650581, 0)
Converted["_yeild"].Size = UDim2.new(0, 346, 0, 50)
Converted["_yeild"].Name = "yeild"
Converted["_yeild"].Parent = Converted["_ScrollingFrame"]

Converted["_TextLabel3"].Font = Enum.Font.SourceSans
Converted["_TextLabel3"].Text = "Script Hub"
Converted["_TextLabel3"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel3"].TextSize = 64
Converted["_TextLabel3"].BackgroundColor3 = Color3.fromRGB(11.000000294297934, 23.000000528991222, 255)
Converted["_TextLabel3"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_TextLabel3"].Position = UDim2.new(0.0311475415, 0, 0.0917647034, 0)
Converted["_TextLabel3"].Size = UDim2.new(0, 548, 0, 50)
Converted["_TextLabel3"].Parent = Converted["_Frame1"]

Converted["_UICorner3"].CornerRadius = UDim.new(0.00999999978, 8)
Converted["_UICorner3"].Parent = Converted["_Frame1"]

Converted["_TextLabel4"].Font = Enum.Font.SourceSans
Converted["_TextLabel4"].Text = "Bulid In Scripts"
Converted["_TextLabel4"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel4"].TextSize = 54
Converted["_TextLabel4"].BackgroundColor3 = Color3.fromRGB(235.0000163912773, 123.00000786781311, 255)
Converted["_TextLabel4"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_TextLabel4"].Position = UDim2.new(0.0819672123, 0, 0.0329411775, 0)
Converted["_TextLabel4"].Size = UDim2.new(0, 490, 0, 50)
Converted["_TextLabel4"].Parent = Converted["_Frame"]

Converted["_UICorner4"].CornerRadius = UDim.new(0.00999999978, 8)
Converted["_UICorner4"].Parent = Converted["_Frame"]

Converted["_Frame3"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_Frame3"].BackgroundTransparency = 0.5
Converted["_Frame3"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_Frame3"].BorderSizePixel = 0
Converted["_Frame3"].Position = UDim2.new(0.021311475, 0, 0.162352934, 0)
Converted["_Frame3"].Size = UDim2.new(0, 584, 0, 345)
Converted["_Frame3"].Parent = Converted["_Frame"]

Converted["_WalkSpeed"].Name = "WalkSpeed"
Converted["_WalkSpeed"].Parent = Converted["_Frame3"]

Converted["_speedon"].Font = Enum.Font.SourceSans
Converted["_speedon"].Text = "Apply"
Converted["_speedon"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_speedon"].TextScaled = true
Converted["_speedon"].TextSize = 14
Converted["_speedon"].TextWrapped = true
Converted["_speedon"].BackgroundColor3 = Color3.fromRGB(55.000004321336746, 255, 0)
Converted["_speedon"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_speedon"].BorderSizePixel = 0
Converted["_speedon"].Position = UDim2.new(0.19520548, 0, 0, 0)
Converted["_speedon"].Size = UDim2.new(0, 55, 0, 50)
Converted["_speedon"].Name = "speedon"
Converted["_speedon"].Parent = Converted["_WalkSpeed"]

Converted["_TextLabel5"].Font = Enum.Font.SourceSans
Converted["_TextLabel5"].Text = "Walkspeed"
Converted["_TextLabel5"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel5"].TextScaled = true
Converted["_TextLabel5"].TextSize = 14
Converted["_TextLabel5"].TextWrapped = true
Converted["_TextLabel5"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel5"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel5"].BorderSizePixel = 0
Converted["_TextLabel5"].Size = UDim2.new(0, 114, 0, 50)
Converted["_TextLabel5"].Parent = Converted["_WalkSpeed"]

Converted["_speed"].CursorPosition = -1
Converted["_speed"].Font = Enum.Font.SourceSans
Converted["_speed"].Text = "16"
Converted["_speed"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_speed"].TextSize = 14
Converted["_speed"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_speed"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_speed"].BorderSizePixel = 0
Converted["_speed"].Position = UDim2.new(0, 0, 0.144927531, 0)
Converted["_speed"].Size = UDim2.new(0, 114, 0, 50)
Converted["_speed"].Name = "speed"
Converted["_speed"].Parent = Converted["_WalkSpeed"]

Converted["_Value"].Value = 16
Converted["_Value"].Parent = Converted["_speed"]

Converted["_JumpPower"].Name = "JumpPower"
Converted["_JumpPower"].Parent = Converted["_Frame3"]

Converted["_jumpon"].Font = Enum.Font.SourceSans
Converted["_jumpon"].Text = "Apply"
Converted["_jumpon"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_jumpon"].TextScaled = true
Converted["_jumpon"].TextSize = 14
Converted["_jumpon"].TextWrapped = true
Converted["_jumpon"].BackgroundColor3 = Color3.fromRGB(55.000004321336746, 255, 0)
Converted["_jumpon"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_jumpon"].BorderSizePixel = 0
Converted["_jumpon"].Position = UDim2.new(0.19520548, 0, 0.295652181, 0)
Converted["_jumpon"].Size = UDim2.new(0, 55, 0, 50)
Converted["_jumpon"].Name = "jumpon"
Converted["_jumpon"].Parent = Converted["_JumpPower"]

Converted["_TextLabel6"].Font = Enum.Font.SourceSans
Converted["_TextLabel6"].Text = "JumpPower"
Converted["_TextLabel6"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel6"].TextScaled = true
Converted["_TextLabel6"].TextSize = 14
Converted["_TextLabel6"].TextWrapped = true
Converted["_TextLabel6"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel6"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel6"].BorderSizePixel = 0
Converted["_TextLabel6"].Position = UDim2.new(0, 0, 0.295652181, 0)
Converted["_TextLabel6"].Size = UDim2.new(0, 114, 0, 50)
Converted["_TextLabel6"].Parent = Converted["_JumpPower"]

Converted["_jump"].CursorPosition = -1
Converted["_jump"].Font = Enum.Font.SourceSans
Converted["_jump"].Text = "50"
Converted["_jump"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_jump"].TextSize = 14
Converted["_jump"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_jump"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_jump"].BorderSizePixel = 0
Converted["_jump"].Position = UDim2.new(0, 0, 0.440579712, 0)
Converted["_jump"].Size = UDim2.new(0, 114, 0, 50)
Converted["_jump"].Name = "jump"
Converted["_jump"].Parent = Converted["_JumpPower"]

Converted["_Air Stuck"].Name = "Air Stuck"
Converted["_Air Stuck"].Parent = Converted["_Frame3"]

Converted["_speedon1"].Font = Enum.Font.SourceSans
Converted["_speedon1"].RichText = true
Converted["_speedon1"].Text = "BIND: C"
Converted["_speedon1"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_speedon1"].TextScaled = true
Converted["_speedon1"].TextSize = 14
Converted["_speedon1"].TextWrapped = true
Converted["_speedon1"].BackgroundColor3 = Color3.fromRGB(55.000004321336746, 255, 0)
Converted["_speedon1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_speedon1"].BorderSizePixel = 0
Converted["_speedon1"].Position = UDim2.new(0.19520548, 0, 0.730434775, 0)
Converted["_speedon1"].Size = UDim2.new(0, 55, 0, 50)
Converted["_speedon1"].Name = "speedon"
Converted["_speedon1"].Parent = Converted["_Air Stuck"]

Converted["_Value1"].Parent = Converted["_speedon1"]

Converted["_TextLabel7"].Font = Enum.Font.SourceSans
Converted["_TextLabel7"].Text = "Air Stuck"
Converted["_TextLabel7"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel7"].TextScaled = true
Converted["_TextLabel7"].TextSize = 14
Converted["_TextLabel7"].TextWrapped = true
Converted["_TextLabel7"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel7"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel7"].BorderSizePixel = 0
Converted["_TextLabel7"].Position = UDim2.new(0, 0, 0.730434775, 0)
Converted["_TextLabel7"].Size = UDim2.new(0, 114, 0, 50)
Converted["_TextLabel7"].Parent = Converted["_Air Stuck"]

Converted["_Fly"].Name = "Fly"
Converted["_Fly"].Parent = Converted["_Frame3"]

Converted["_jumpon1"].Font = Enum.Font.SourceSans
Converted["_jumpon1"].Text = "Apply"
Converted["_jumpon1"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_jumpon1"].TextScaled = true
Converted["_jumpon1"].TextSize = 14
Converted["_jumpon1"].TextWrapped = true
Converted["_jumpon1"].BackgroundColor3 = Color3.fromRGB(55.000004321336746, 255, 0)
Converted["_jumpon1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_jumpon1"].BorderSizePixel = 0
Converted["_jumpon1"].Position = UDim2.new(0.19520548, 0, 0.585507274, 0)
Converted["_jumpon1"].Size = UDim2.new(0, 55, 0, 50)
Converted["_jumpon1"].Name = "jumpon"
Converted["_jumpon1"].Parent = Converted["_Fly"]

Converted["_TextLabel8"].Font = Enum.Font.SourceSans
Converted["_TextLabel8"].Text = "Fly"
Converted["_TextLabel8"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel8"].TextScaled = true
Converted["_TextLabel8"].TextSize = 14
Converted["_TextLabel8"].TextWrapped = true
Converted["_TextLabel8"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel8"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel8"].BorderSizePixel = 0
Converted["_TextLabel8"].Position = UDim2.new(0, 0, 0.585507274, 0)
Converted["_TextLabel8"].Size = UDim2.new(0, 114, 0, 50)
Converted["_TextLabel8"].Parent = Converted["_Fly"]

Converted["_Fake Lag"].Name = "Fake Lag"
Converted["_Fake Lag"].Parent = Converted["_Frame3"]

Converted["_jumpon2"].Font = Enum.Font.SourceSans
Converted["_jumpon2"].Text = "Apply"
Converted["_jumpon2"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_jumpon2"].TextScaled = true
Converted["_jumpon2"].TextSize = 14
Converted["_jumpon2"].TextWrapped = true
Converted["_jumpon2"].BackgroundColor3 = Color3.fromRGB(55.000004321336746, 255, 0)
Converted["_jumpon2"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_jumpon2"].BorderSizePixel = 0
Converted["_jumpon2"].Position = UDim2.new(0.19520548, 0, 0.875362337, 0)
Converted["_jumpon2"].Size = UDim2.new(0, 55, 0, 50)
Converted["_jumpon2"].Name = "jumpon"
Converted["_jumpon2"].Parent = Converted["_Fake Lag"]

Converted["_TextLabel9"].Font = Enum.Font.SourceSans
Converted["_TextLabel9"].Text = "Fake lag (BAD)"
Converted["_TextLabel9"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel9"].TextScaled = true
Converted["_TextLabel9"].TextSize = 14
Converted["_TextLabel9"].TextWrapped = true
Converted["_TextLabel9"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel9"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel9"].BorderSizePixel = 0
Converted["_TextLabel9"].Position = UDim2.new(0, 0, 0.875362337, 0)
Converted["_TextLabel9"].Size = UDim2.new(0, 114, 0, 50)
Converted["_TextLabel9"].Parent = Converted["_Fake Lag"]

Converted["_TextLabel10"].Font = Enum.Font.SourceSans
Converted["_TextLabel10"].Text = "Xeon/XExploit 1.1"
Converted["_TextLabel10"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel10"].TextSize = 64
Converted["_TextLabel10"].BackgroundColor3 = Color3.fromRGB(11.000000294297934, 23.000000528991222, 255)
Converted["_TextLabel10"].BorderColor3 = Color3.fromRGB(27.000002190470695, 42.000001296401024, 53.000004440546036)
Converted["_TextLabel10"].Position = UDim2.new(0.0300959162, 0, 0.0542371161, 0)
Converted["_TextLabel10"].Size = UDim2.new(0, 899, 0, 50)
Converted["_TextLabel10"].Parent = Converted["_datac1"]

Converted["_TextButton2"].Font = Enum.Font.SourceSans
Converted["_TextButton2"].Text = "Open or Close"
Converted["_TextButton2"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextButton2"].TextScaled = true
Converted["_TextButton2"].TextSize = 14
Converted["_TextButton2"].TextWrapped = true
Converted["_TextButton2"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextButton2"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextButton2"].BorderSizePixel = 0
Converted["_TextButton2"].Position = UDim2.new(0.944382668, 0, 0, 0)
Converted["_TextButton2"].Size = UDim2.new(0, 58, 0, 50)
Converted["_TextButton2"].Parent = Converted["_TextLabel10"]

Converted["_uncchecker"].BackgroundColor3 = Color3.fromRGB(136.00000709295273, 0, 255)
Converted["_uncchecker"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_uncchecker"].BorderSizePixel = 0
Converted["_uncchecker"].Position = UDim2.new(0.0347003154, 0, 0.835575461, 0)
Converted["_uncchecker"].Size = UDim2.new(0, 891, 0, 100)
Converted["_uncchecker"].Name = "uncchecker"
Converted["_uncchecker"].Parent = Converted["_datac1"]

Converted["_green"].Font = Enum.Font.SourceSans
Converted["_green"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_green"].TextScaled = true
Converted["_green"].TextSize = 14
Converted["_green"].TextWrapped = true
Converted["_green"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_green"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_green"].BorderSizePixel = 0
Converted["_green"].Position = UDim2.new(0.639730632, 0, 0, 0)
Converted["_green"].Size = UDim2.new(0, 321, 0, 31)
Converted["_green"].Name = "green"
Converted["_green"].Parent = Converted["_uncchecker"]

Converted["_red"].Font = Enum.Font.SourceSans
Converted["_red"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_red"].TextScaled = true
Converted["_red"].TextSize = 14
Converted["_red"].TextWrapped = true
Converted["_red"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_red"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_red"].BorderSizePixel = 0
Converted["_red"].Position = UDim2.new(0.639730632, 0, 0.310000002, 0)
Converted["_red"].Size = UDim2.new(0, 321, 0, 35)
Converted["_red"].Name = "red"
Converted["_red"].Parent = Converted["_uncchecker"]

Converted["_yellow"].Font = Enum.Font.SourceSans
Converted["_yellow"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_yellow"].TextScaled = true
Converted["_yellow"].TextSize = 14
Converted["_yellow"].TextWrapped = true
Converted["_yellow"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_yellow"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_yellow"].BorderSizePixel = 0
Converted["_yellow"].Position = UDim2.new(0.639730632, 0, 0.660000026, 0)
Converted["_yellow"].Size = UDim2.new(0, 321, 0, 34)
Converted["_yellow"].Name = "yellow"
Converted["_yellow"].Parent = Converted["_uncchecker"]

Converted["_TextLabel11"].Font = Enum.Font.SourceSans
Converted["_TextLabel11"].Text = "UNC Checker Bulid-In"
Converted["_TextLabel11"].TextColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel11"].TextScaled = true
Converted["_TextLabel11"].TextSize = 14
Converted["_TextLabel11"].TextWrapped = true
Converted["_TextLabel11"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_TextLabel11"].BackgroundTransparency = 1
Converted["_TextLabel11"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_TextLabel11"].BorderSizePixel = 0
Converted["_TextLabel11"].Position = UDim2.new(0.0224466883, 0, 0.25, 0)
Converted["_TextLabel11"].Size = UDim2.new(0, 348, 0, 50)
Converted["_TextLabel11"].Parent = Converted["_uncchecker"]

Converted["_UICorner5"].CornerRadius = UDim.new(0.0500000007, 8)
Converted["_UICorner5"].Parent = Converted["_datac1"]

-- Fake Module Scripts:

local fake_module_scripts = {}


-- Fake Local Scripts:

local function MZCDPW_fake_script() -- Fake Script: StarterGui.ScreenGui.launcher.TextButton.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_TextButton"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- Reference the button
	local button = script.Parent
	
	-- Define what happens when the button is clicked
	local function onButtonClick()
		print("xeonlauncher: loading xeon...")
		wait (0.5)
		print("xeonlauncher: checking menu")
		if script.Parent.Parent.Parent.datac1.Visible then
			print("xeonlauncher: menu err1.1")
			script.Parent.Parent.Parent.launcher.Visible = false
			script.Parent.Parent.Parent.datac1.Visible = false
			script.Parent.Parent.Parent.popup.popuptext.Text = "ERR 1.1 | Restart..."
			script.Parent.Parent.Parent.popup.LocalScript.Disabled = false
			wait(5)
			print("xeonlauncher: menu ok")
			wait(0.5)
			script.Parent.Parent.Parent.launcher.Visible = false
			script.Parent.Parent.Parent.popup.popuptext.Text = "Loaded script"
			script.Parent.Parent.Parent.popup.LocalScript.Disabled = false
			script.Parent.Parent.Parent.datac1.Visible = true
		else
			print("xeonlauncher: menu ok")
			wait(0.5)
			script.Parent.Parent.Parent.launcher.Visible = false
			script.Parent.Parent.Parent.popup.popuptext.Text = "Loaded script"
			script.Parent.Parent.Parent.popup.LocalScript.Disabled = false
			script.Parent.Parent.Parent.datac1.Visible = true
		end
		
	end
	
	
	
	-- Connect the function to the button's MouseButton1Click event
	button.MouseButton1Click:Connect(onButtonClick)
	
end
local function FAYDP_fake_script() -- Fake Script: StarterGui.ScreenGui.launcher.TextButton.wait
    local script = Instance.new("LocalScript")
    script.Name = "wait"
    script.Parent = Converted["_TextButton"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	script.Parent.LocalScript.Disabled = true
	script.Parent.Parent.TextButton.Text = "Load (5)"
	wait(1)
	script.Parent.Parent.TextButton.Text = "Load (4)"
	wait(1)
	script.Parent.Parent.TextButton.Text = "Load (3)"
	wait(1)
	script.Parent.Parent.TextButton.Text = "Load (2)"
	wait(1)
	script.Parent.Parent.TextButton.Text = "Load (1)"
	wait(1)
	script.Parent.LocalScript.Disabled = false
	script.Parent.Parent.TextButton.Text = "Load"
	script.Disabled = true
end
local function HPDCYS_fake_script() -- Fake Script: StarterGui.ScreenGui.launcher.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_launcher"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	
	local frame = script.Parent
	local dragging = false
	local dragInput
	local dragStart
	local startPos
	
	-- Function to update the frame's position as it is dragged
	local function update(input)
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
	
	-- When a drag starts
	frame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	-- When dragging is ongoing
	frame.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			dragInput = input
		end
	end)
	
	-- Update frame position while dragging
	game:GetService("UserInputService").InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
	
end
local function NHQUAFU_fake_script() -- Fake Script: StarterGui.ScreenGui.popup.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_popup"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	script.Parent.Parent.popup.Visible = true
	wait(5)
	script.Parent.Parent.popup.Visible = false
	script.Disabled = true
end
local function XHHTXN_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.Frame.ScrollingFrame.ezhub.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_ezhub"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- Reference the button
	local button = script.Parent
	
	-- Define what happens when the button is clicked
	local function onButtonClick()
		print("xeonload: loaded Ez-Hub")
		loadstring(game:HttpGet(('https://raw.githubusercontent.com/debug42O/Ez-Industries-Launcher-Data/master/Launcher.lua'),true))()
		-- You can replace this with any action you'd like, e.g.:
		-- button.Text = "Clicked!"
		-- game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 20
	end
	
	-- Connect the function to the button's MouseButton1Click event
	button.MouseButton1Click:Connect(onButtonClick)
	
end
local function ETFWBO_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.Frame.ScrollingFrame.archiveadminhub.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_archiveadminhub"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- Reference the button
	local button = script.Parent
	
	-- Define what happens when the button is clicked
	local function onButtonClick()
		print("xeonload: aa hub")
		loadstring(game:HttpGet('https://raw.githubusercontent.com/Lucasfin000/SpaceHub/main/UESP'))()
		-- You can replace this with any action you'd like, e.g.:
		-- button.Text = "Clicked!"
		-- game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 20
	end
	
	-- Connect the function to the button's MouseButton1Click event
	button.MouseButton1Click:Connect(onButtonClick)
	
end
local function VBQOOJX_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.Frame.ScrollingFrame.dex.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_dex"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- Reference the button
	local button = script.Parent
	
	-- Define what happens when the button is clicked
	local function onButtonClick()
		print("xeonload: dex")
		loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Dex%20Explorer.txt"))()
		-- You can replace this with any action you'd like, e.g.:
		-- button.Text = "Clicked!"
		-- game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 20
	end
	
	-- Connect the function to the button's MouseButton1Click event
	button.MouseButton1Click:Connect(onButtonClick)
	
end
local function LFLPZE_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.Frame.ScrollingFrame.yeild.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_yeild"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- Reference the button
	local button = script.Parent
	
	-- Define what happens when the button is clicked
	local function onButtonClick()
		print("xeonload: infinite yield")
		loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Infinite%20Yield.txt"))()
		-- You can replace this with any action you'd like, e.g.:
		-- button.Text = "Clicked!"
		-- game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 20
	end
	
	-- Connect the function to the button's MouseButton1Click event
	button.MouseButton1Click:Connect(onButtonClick)
	
end
local function WOBKQGO_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.WalkSpeed.speed.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_speed"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- LocalScript inside ScreenGui
	
	local player = game.Players.LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")
	
	local textBox = script.Parent.Parent:WaitForChild("speed") -- Reference to the TextBox
	local applyButton = script.Parent.Parent:WaitForChild("speedon")  -- Reference to the Apply Button
	
	-- Function to set WalkSpeed based on input
	local function setWalkSpeed()
		local inputSpeed = tonumber(textBox.Text)  -- Convert TextBox input to a number
	
		-- Check if input is a valid number
		if inputSpeed then
			humanoid.WalkSpeed = inputSpeed
		end
	end
	
	-- Connect the function to the Apply Button's click event
	applyButton.MouseButton1Click:Connect(setWalkSpeed)
	
end
local function NZUF_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.JumpPower.jump.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_jump"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- LocalScript inside ScreenGui
	
	local player = game.Players.LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")
	
	local textBox = script.Parent.Parent:WaitForChild("jump") -- Reference to the TextBox
	local applyButton = script.Parent.Parent:WaitForChild("jumpon")  -- Reference to the Apply Button
	
	-- Function to set WalkSpeed based on input
	local function setWalkSpeed()
		local inputSpeed = tonumber(textBox.Text)  -- Convert TextBox input to a number
	
		-- Check if input is a valid number
		if inputSpeed then
			humanoid.JumpPower = inputSpeed
		end
	end
	
	-- Connect the function to the Apply Button's click event
	applyButton.MouseButton1Click:Connect(setWalkSpeed)
	
end
local function MGXAS_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.Air Stuck.speedon.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_speedon1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- LocalScript (FlyScript)
	
	local player = game.Players.LocalPlayer
	local mouse = player:GetMouse()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")
	local hrp = character:WaitForChild("HumanoidRootPart")
	
	local flying = false
	local flySpeed = 50  -- Adjust flying speed here
	local bodyVelocity
	
	-- Function to start flying
	local function startFlying()
		-- Check if already flying
		if flying then return end
		flying = true
	
		-- Create a BodyVelocity object
		bodyVelocity = Instance.new("BodyVelocity")
		bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)  -- Max force for all axes
		bodyVelocity.Velocity = Vector3.new(0, 0, 0)  -- Start with no movement
		bodyVelocity.P = 5000  -- Strength of the force applied
	
		bodyVelocity.Parent = hrp
	end
	
	-- Function to stop flying
	local function stopFlying()
		-- Check if already not flying
		if not flying then return end
		flying = false
	
		-- Remove BodyVelocity when stopping flight
		if bodyVelocity then
			bodyVelocity:Destroy()
		end
	end
	
	-- Update flying movement based on keyboard input
	local function updateFlyMovement()
		if flying then
			local direction = Vector3.new(0, 0, 0)
	
			-- Movement controls for flying
			if mouse:IsKeyDown(Enum.KeyCode.W) then
				direction = direction + hrp.CFrame.LookVector  -- Forward
			end
			if mouse:IsKeyDown(Enum.KeyCode.S) then
				direction = direction - hrp.CFrame.LookVector  -- Backward
			end
			if mouse:IsKeyDown(Enum.KeyCode.A) then
				direction = direction - hrp.CFrame.RightVector  -- Left
			end
			if mouse:IsKeyDown(Enum.KeyCode.D) then
				direction = direction + hrp.CFrame.RightVector  -- Right
			end
			if mouse:IsKeyDown(Enum.KeyCode.Space) then
				direction = direction + Vector3.new(0, 1, 0)  -- Up
			end
			if mouse:IsKeyDown(Enum.KeyCode.LeftControl) then
				direction = direction - Vector3.new(0, 1, 0)  -- Down
			end
	
			-- Set the flying speed and apply the direction
			bodyVelocity.Velocity = direction * flySpeed
		end
	end
	local button = script.Parent
	-- Toggle flying on and off with the "F" key
	mouse.KeyDown:Connect(function(key)
		if key:lower() == "c" then
			if flying then
				stopFlying()
			else
				startFlying()
			end
		end
	end)
	
	-- Continuously update flying movement
	game:GetService("RunService").Heartbeat:Connect(updateFlyMovement)
	
end
local function GPNM_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.Fly.jumpon.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_jumpon1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- Press X to fly
	
	local plr = game.Players.LocalPlayer
	local mouse = plr:GetMouse()
	
	localplayer = plr
	
	if workspace:FindFirstChild("Core") then
		workspace.Core:Destroy()
	end
	
	local Core = Instance.new("Part")
	Core.Name = "Core"
	Core.Size = Vector3.new(0.05, 0.05, 0.05)
	
	spawn(function()
		Core.Parent = workspace
		local Weld = Instance.new("Weld", Core)
		Weld.Part0 = Core
		Weld.Part1 = localplayer.Character.LowerTorso
		Weld.C0 = CFrame.new(0, 0, 0)
	end)
	
	workspace:WaitForChild("Core")
	
	local torso = workspace.Core
	flying = true
	local speed=10
	local keys={a=false,d=false,w=false,s=false}
	local e1
	local e2
	local function start()
		local pos = Instance.new("BodyPosition",torso)
		local gyro = Instance.new("BodyGyro",torso)
		pos.Name="EPIXPOS"
		pos.maxForce = Vector3.new(math.huge, math.huge, math.huge)
		pos.position = torso.Position
		gyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
		gyro.cframe = torso.CFrame
		repeat
			wait()
			localplayer.Character.Humanoid.PlatformStand=true
			local new=gyro.cframe - gyro.cframe.p + pos.position
			if not keys.w and not keys.s and not keys.a and not keys.d then
				speed=5
			end
			if keys.w then
				new = new + workspace.CurrentCamera.CoordinateFrame.lookVector * speed
				speed=speed+0
			end
			if keys.s then
				new = new - workspace.CurrentCamera.CoordinateFrame.lookVector * speed
				speed=speed+0
			end
			if keys.d then
				new = new * CFrame.new(speed,0,0)
				speed=speed+0
			end
			if keys.a then
				new = new * CFrame.new(-speed,0,0)
				speed=speed+0
			end
			if speed>10 then
				speed=5
			end
			pos.position=new.p
			if keys.w then
				gyro.cframe = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(-math.rad(speed*0),0,0)
			elseif keys.s then
				gyro.cframe = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(math.rad(speed*0),0,0)
			else
				gyro.cframe = workspace.CurrentCamera.CoordinateFrame
			end
		until flying == false
		if gyro then gyro:Destroy() end
		if pos then pos:Destroy() end
		flying=false
		localplayer.Character.Humanoid.PlatformStand=false
		speed=10
	end
	e1=mouse.KeyDown:connect(function(key)
		if not torso or not torso.Parent then flying=false e1:disconnect() e2:disconnect() return end
		if key=="w" then
			keys.w=true
		elseif key=="s" then
			keys.s=true
		elseif key=="a" then
			keys.a=true
		elseif key=="d" then
			keys.d=true
		elseif key=="x" then
			if flying==true then
				flying=false
			else
				flying=true
				start()
			end
		end
	end)
	e2=mouse.KeyUp:connect(function(key)
		if key=="w" then
			keys.w=false
		elseif key=="s" then
			keys.s=false
		elseif key=="a" then
			keys.a=false
		elseif key=="d" then
			keys.d=false
		end
	end)
	
	
	
	local button = script.Parent
	
	-- Define what happens when the button is clicked
	local function onButtonClick()
		start()
	end
	
	
	
	-- Connect the function to the button's MouseButton1Click event
	button.MouseButton1Click:Connect(onButtonClick)
end
local function LBXJYD_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.Frame.Frame.Fake Lag.jumpon.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_jumpon2"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	-- LocalScript (FakeLag)
	
	local player = game.Players.LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local hrp = character:WaitForChild("HumanoidRootPart")
	local mouse = player:GetMouse()
	
	local lagEnabled = false  -- False to disable fake lag, True to enable it
	local lagAmount = 0.3     -- Adjust to control the lag delay (in seconds)
	local originalSpeed = 16  -- Default walk speed
	local fakeLagSpeed = 2    -- Speed while lag is enabled
	
	-- Function to simulate fake lag
	local function simulateLag()
		while lagEnabled do
			-- Temporarily reduce walk speed to simulate lag
			character.Humanoid.WalkSpeed = fakeLagSpeed
	
			-- Wait for a short time (this controls the lag delay)
			wait(lagAmount)
	
			-- Return to normal walk speed after delay
			character.Humanoid.WalkSpeed = originalSpeed
	
			-- Introduce a delay before the next movement
			wait(lagAmount)
		end
	end
	
	-- Toggle fake lag on or off when "L" key is pressed
	mouse.KeyDown:Connect(function(key)
		if key:lower() == "l" then
			lagEnabled = not lagEnabled  -- Toggle lag state
			if lagEnabled then
				-- Start the fake lag simulation
				simulateLag()
			else
				-- Reset the walk speed to normal when fake lag is off
				character.Humanoid.WalkSpeed = originalSpeed
			end
		end
	end)
	
end
local function OMVFX_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.TextLabel.TextButton.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_TextButton2"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	
	local button = script.Parent
	
	-- Define what happens when the button is clicked
	local function onButtonClick()
		if script.Parent.Parent.Parent.Frame.Visible == true then
			script.Parent.Parent.Parent.uncchecker.Visible = false
			script.Parent.Parent.Parent.Parent.datac1.Transparency = 1
			script.Parent.Parent.Parent.Frame.Visible = false
		else
			script.Parent.Parent.Parent.uncchecker.Visible = true
			script.Parent.Parent.Parent.Parent.datac1.Transparency = 0
			script.Parent.Parent.Parent.Frame.Visible = true
		end
	end
	
	
	
	-- Connect the function to the button's MouseButton1Click event
	button.MouseButton1Click:Connect(onButtonClick)
	
end
local function PWHX_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.uncchecker.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_uncchecker"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	local passes, fails, undefined = 0, 0, 0
	local running = 0
	
	local function getGlobal(path)
		local value = getfenv(0)
	
		while value ~= nil and path ~= "" do
			local name, nextValue = string.match(path, "^([^.]+)%.?(.*)$")
			value = value[name]
			path = nextValue
		end
	
		return value
	end
	
	local function test(name, aliases, callback)
		running += 1
	
		task.spawn(function()
			if not callback then
				print("⏺️ " .. name)
			elseif not getGlobal(name) then
				fails += 1
				warn("⛔ " .. name)
			else
				local success, message = pcall(callback)
	
				if success then
					passes += 1
					print("✅ " .. name .. (message and " • " .. message or ""))
				else
					fails += 1
					warn("⛔ " .. name .. " failed: " .. message)
				end
			end
	
			local undefinedAliases = {}
	
			for _, alias in ipairs(aliases) do
				if getGlobal(alias) == nil then
					table.insert(undefinedAliases, alias)
				end
			end
	
			if #undefinedAliases > 0 then
				undefined += 1
				warn("⚠️ " .. table.concat(undefinedAliases, ", "))
			end
	
			running -= 1
		end)
	end
	
	-- Header and summary
	
	print("\n")
	
	print("UNC Environment Check")
	print("✅ - Pass, ⛔ - Fail, ⏺️ - No test, ⚠️ - Missing aliases\n")
	
	task.defer(function()
		repeat task.wait() until running == 0
	
		local rate = math.round(passes / (passes + fails) * 100)
		local outOf = passes .. " out of " .. (passes + fails)
	
		print("\n")
	
		print("UNC Summary")
		print("✅ Tested with a " .. rate .. "% success rate (" .. outOf .. ")")
		print("⛔ " .. fails .. " tests failed")
		print("⚠️ " .. undefined .. " globals are missing aliases")
		script.Parent.green.Text = "✅ Tested with a " .. rate .. "% success rate (" .. outOf .. ")"
		script.Parent.red.Text = "⛔ " .. fails .. " tests failed"
		script.Parent.yellow.Text = "⚠️ " .. undefined .. " globals are missing aliases"
	end)
	
	-- Cache
	
	test("cache.invalidate", {}, function()
		local container = Instance.new("Folder")
		local part = Instance.new("Part", container)
		cache.invalidate(container:FindFirstChild("Part"))
		assert(part ~= container:FindFirstChild("Part"), "Reference `part` could not be invalidated")
	end)
	
	test("cache.iscached", {}, function()
		local part = Instance.new("Part")
		assert(cache.iscached(part), "Part should be cached")
		cache.invalidate(part)
		assert(not cache.iscached(part), "Part should not be cached")
	end)
	
	test("cache.replace", {}, function()
		local part = Instance.new("Part")
		local fire = Instance.new("Fire")
		cache.replace(part, fire)
		assert(part ~= fire, "Part was not replaced with Fire")
	end)
	
	test("cloneref", {}, function()
		local part = Instance.new("Part")
		local clone = cloneref(part)
		assert(part ~= clone, "Clone should not be equal to original")
		clone.Name = "Test"
		assert(part.Name == "Test", "Clone should have updated the original")
	end)
	
	test("compareinstances", {}, function()
		local part = Instance.new("Part")
		local clone = cloneref(part)
		assert(part ~= clone, "Clone should not be equal to original")
		assert(compareinstances(part, clone), "Clone should be equal to original when using compareinstances()")
	end)
	
	-- Closures
	
	local function shallowEqual(t1, t2)
		if t1 == t2 then
			return true
		end
	
		local UNIQUE_TYPES = {
			["function"] = true,
			["table"] = true,
			["userdata"] = true,
			["thread"] = true,
		}
	
		for k, v in pairs(t1) do
			if UNIQUE_TYPES[type(v)] then
				if type(t2[k]) ~= type(v) then
					return false
				end
			elseif t2[k] ~= v then
				return false
			end
		end
	
		for k, v in pairs(t2) do
			if UNIQUE_TYPES[type(v)] then
				if type(t2[k]) ~= type(v) then
					return false
				end
			elseif t1[k] ~= v then
				return false
			end
		end
	
		return true
	end
	
	test("checkcaller", {}, function()
		assert(checkcaller(), "Main scope should return true")
	end)
	
	test("clonefunction", {}, function()
		local function test()
			return "success"
		end
		local copy = clonefunction(test)
		assert(test() == copy(), "The clone should return the same value as the original")
		assert(test ~= copy, "The clone should not be equal to the original")
	end)
	
	test("getcallingscript", {})
	
	test("getscriptclosure", {"getscriptfunction"}, function()
		local module = game:GetService("CoreGui").RobloxGui.Modules.Common.Constants
		local constants = getrenv().require(module)
		local generated = getscriptclosure(module)()
		assert(constants ~= generated, "Generated module should not match the original")
		assert(shallowEqual(constants, generated), "Generated constant table should be shallow equal to the original")
	end)
	
	test("hookfunction", {"replaceclosure"}, function()
		local function test()
			return true
		end
		local ref = hookfunction(test, function()
			return false
		end)
		assert(test() == false, "Function should return false")
		assert(ref() == true, "Original function should return true")
		assert(test ~= ref, "Original function should not be same as the reference")
	end)
	
	test("iscclosure", {}, function()
		assert(iscclosure(print) == true, "Function 'print' should be a C closure")
		assert(iscclosure(function() end) == false, "Executor function should not be a C closure")
	end)
	
	test("islclosure", {}, function()
		assert(islclosure(print) == false, "Function 'print' should not be a Lua closure")
		assert(islclosure(function() end) == true, "Executor function should be a Lua closure")
	end)
	
	test("isexecutorclosure", {"checkclosure", "isourclosure"}, function()
		assert(isexecutorclosure(isexecutorclosure) == true, "Did not return true for an executor global")
		assert(isexecutorclosure(newcclosure(function() end)) == true, "Did not return true for an executor C closure")
		assert(isexecutorclosure(function() end) == true, "Did not return true for an executor Luau closure")
		assert(isexecutorclosure(print) == false, "Did not return false for a Roblox global")
	end)
	
	test("loadstring", {}, function()
		local animate = game:GetService("Players").LocalPlayer.Character.Animate
		local bytecode = getscriptbytecode(animate)
		local func = loadstring(bytecode)
		assert(type(func) ~= "function", "Luau bytecode should not be loadable!")
		assert(assert(loadstring("return ... + 1"))(1) == 2, "Failed to do simple math")
		assert(type(select(2, loadstring("f"))) == "string", "Loadstring did not return anything for a compiler error")
	end)
	
	test("newcclosure", {}, function()
		local function test()
			return true
		end
		local testC = newcclosure(test)
		assert(test() == testC(), "New C closure should return the same value as the original")
		assert(test ~= testC, "New C closure should not be same as the original")
		assert(iscclosure(testC), "New C closure should be a C closure")
	end)
	
	-- Console
	
	test("rconsoleclear", {"consoleclear"})
	
	test("rconsolecreate", {"consolecreate"})
	
	test("rconsoledestroy", {"consoledestroy"})
	
	test("rconsoleinput", {"consoleinput"})
	
	test("rconsoleprint", {"consoleprint"})
	
	test("rconsolesettitle", {"rconsolename", "consolesettitle"})
	
	-- Crypt
	
	test("crypt.base64encode", {"crypt.base64.encode", "crypt.base64_encode", "base64.encode", "base64_encode"}, function()
		assert(crypt.base64encode("test") == "dGVzdA==", "Base64 encoding failed")
	end)
	
	test("crypt.base64decode", {"crypt.base64.decode", "crypt.base64_decode", "base64.decode", "base64_decode"}, function()
		assert(crypt.base64decode("dGVzdA==") == "test", "Base64 decoding failed")
	end)
	
	test("crypt.encrypt", {}, function()
		local key = crypt.generatekey()
		local encrypted, iv = crypt.encrypt("test", key, nil, "CBC")
		assert(iv, "crypt.encrypt should return an IV")
		local decrypted = crypt.decrypt(encrypted, key, iv, "CBC")
		assert(decrypted == "test", "Failed to decrypt raw string from encrypted data")
	end)
	
	test("crypt.decrypt", {}, function()
		local key, iv = crypt.generatekey(), crypt.generatekey()
		local encrypted = crypt.encrypt("test", key, iv, "CBC")
		local decrypted = crypt.decrypt(encrypted, key, iv, "CBC")
		assert(decrypted == "test", "Failed to decrypt raw string from encrypted data")
	end)
	
	test("crypt.generatebytes", {}, function()
		local size = math.random(10, 100)
		local bytes = crypt.generatebytes(size)
		assert(#crypt.base64decode(bytes) == size, "The decoded result should be " .. size .. " bytes long (got " .. #crypt.base64decode(bytes) .. " decoded, " .. #bytes .. " raw)")
	end)
	
	test("crypt.generatekey", {}, function()
		local key = crypt.generatekey()
		assert(#crypt.base64decode(key) == 32, "Generated key should be 32 bytes long when decoded")
	end)
	
	test("crypt.hash", {}, function()
		local algorithms = {'sha1', 'sha384', 'sha512', 'md5', 'sha256', 'sha3-224', 'sha3-256', 'sha3-512'}
		for _, algorithm in ipairs(algorithms) do
			local hash = crypt.hash("test", algorithm)
			assert(hash, "crypt.hash on algorithm '" .. algorithm .. "' should return a hash")
		end
	end)
	
	--- Debug
	
	test("debug.getconstant", {}, function()
		local function test()
			print("Hello, world!")
		end
		assert(debug.getconstant(test, 1) == "print", "First constant must be print")
		assert(debug.getconstant(test, 2) == nil, "Second constant must be nil")
		assert(debug.getconstant(test, 3) == "Hello, world!", "Third constant must be 'Hello, world!'")
	end)
	
	test("debug.getconstants", {}, function()
		local function test()
			local num = 5000 .. 50000
			print("Hello, world!", num, warn)
		end
		local constants = debug.getconstants(test)
		assert(constants[1] == 50000, "First constant must be 50000")
		assert(constants[2] == "print", "Second constant must be print")
		assert(constants[3] == nil, "Third constant must be nil")
		assert(constants[4] == "Hello, world!", "Fourth constant must be 'Hello, world!'")
		assert(constants[5] == "warn", "Fifth constant must be warn")
	end)
	
	test("debug.getinfo", {}, function()
		local types = {
			source = "string",
			short_src = "string",
			func = "function",
			what = "string",
			currentline = "number",
			name = "string",
			nups = "number",
			numparams = "number",
			is_vararg = "number",
		}
		local function test(...)
			print(...)
		end
		local info = debug.getinfo(test)
		for k, v in pairs(types) do
			assert(info[k] ~= nil, "Did not return a table with a '" .. k .. "' field")
			assert(type(info[k]) == v, "Did not return a table with " .. k .. " as a " .. v .. " (got " .. type(info[k]) .. ")")
		end
	end)
	
	test("debug.getproto", {}, function()
		local function test()
			local function proto()
				return true
			end
		end
		local proto = debug.getproto(test, 1, true)[1]
		local realproto = debug.getproto(test, 1)
		assert(proto, "Failed to get the inner function")
		assert(proto() == true, "The inner function did not return anything")
		if not realproto() then
			return "Proto return values are disabled on this executor"
		end
	end)
	
	test("debug.getprotos", {}, function()
		local function test()
			local function _1()
				return true
			end
			local function _2()
				return true
			end
			local function _3()
				return true
			end
		end
		for i in ipairs(debug.getprotos(test)) do
			local proto = debug.getproto(test, i, true)[1]
			local realproto = debug.getproto(test, i)
			assert(proto(), "Failed to get inner function " .. i)
			if not realproto() then
				return "Proto return values are disabled on this executor"
			end
		end
	end)
	
	test("debug.getstack", {}, function()
		local _ = "a" .. "b"
		assert(debug.getstack(1, 1) == "ab", "The first item in the stack should be 'ab'")
		assert(debug.getstack(1)[1] == "ab", "The first item in the stack table should be 'ab'")
	end)
	
	test("debug.getupvalue", {}, function()
		local upvalue = function() end
		local function test()
			print(upvalue)
		end
		assert(debug.getupvalue(test, 1) == upvalue, "Unexpected value returned from debug.getupvalue")
	end)
	
	test("debug.getupvalues", {}, function()
		local upvalue = function() end
		local function test()
			print(upvalue)
		end
		local upvalues = debug.getupvalues(test)
		assert(upvalues[1] == upvalue, "Unexpected value returned from debug.getupvalues")
	end)
	
	test("debug.setconstant", {}, function()
		local function test()
			return "fail"
		end
		debug.setconstant(test, 1, "success")
		assert(test() == "success", "debug.setconstant did not set the first constant")
	end)
	
	test("debug.setstack", {}, function()
		local function test()
			return "fail", debug.setstack(1, 1, "success")
		end
		assert(test() == "success", "debug.setstack did not set the first stack item")
	end)
	
	test("debug.setupvalue", {}, function()
		local function upvalue()
			return "fail"
		end
		local function test()
			return upvalue()
		end
		debug.setupvalue(test, 1, function()
			return "success"
		end)
		assert(test() == "success", "debug.setupvalue did not set the first upvalue")
	end)
	
	-- Filesystem
	
	if isfolder and makefolder and delfolder then
		if isfolder(".tests") then
			delfolder(".tests")
		end
		makefolder(".tests")
	end
	
	test("readfile", {}, function()
		writefile(".tests/readfile.txt", "success")
		assert(readfile(".tests/readfile.txt") == "success", "Did not return the contents of the file")
	end)
	
	test("listfiles", {}, function()
		makefolder(".tests/listfiles")
		writefile(".tests/listfiles/test_1.txt", "success")
		writefile(".tests/listfiles/test_2.txt", "success")
		local files = listfiles(".tests/listfiles")
		assert(#files == 2, "Did not return the correct number of files")
		assert(isfile(files[1]), "Did not return a file path")
		assert(readfile(files[1]) == "success", "Did not return the correct files")
		makefolder(".tests/listfiles_2")
		makefolder(".tests/listfiles_2/test_1")
		makefolder(".tests/listfiles_2/test_2")
		local folders = listfiles(".tests/listfiles_2")
		assert(#folders == 2, "Did not return the correct number of folders")
		assert(isfolder(folders[1]), "Did not return a folder path")
	end)
	
	test("writefile", {}, function()
		writefile(".tests/writefile.txt", "success")
		assert(readfile(".tests/writefile.txt") == "success", "Did not write the file")
		local requiresFileExt = pcall(function()
			writefile(".tests/writefile", "success")
			assert(isfile(".tests/writefile.txt"))
		end)
		if not requiresFileExt then
			return "This executor requires a file extension in writefile"
		end
	end)
	
	test("makefolder", {}, function()
		makefolder(".tests/makefolder")
		assert(isfolder(".tests/makefolder"), "Did not create the folder")
	end)
	
	test("appendfile", {}, function()
		writefile(".tests/appendfile.txt", "su")
		appendfile(".tests/appendfile.txt", "cce")
		appendfile(".tests/appendfile.txt", "ss")
		assert(readfile(".tests/appendfile.txt") == "success", "Did not append the file")
	end)
	
	test("isfile", {}, function()
		writefile(".tests/isfile.txt", "success")
		assert(isfile(".tests/isfile.txt") == true, "Did not return true for a file")
		assert(isfile(".tests") == false, "Did not return false for a folder")
		assert(isfile(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path (got " .. tostring(isfile(".tests/doesnotexist.exe")) .. ")")
	end)
	
	test("isfolder", {}, function()
		assert(isfolder(".tests") == true, "Did not return false for a folder")
		assert(isfolder(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path (got " .. tostring(isfolder(".tests/doesnotexist.exe")) .. ")")
	end)
	
	test("delfolder", {}, function()
		makefolder(".tests/delfolder")
		delfolder(".tests/delfolder")
		assert(isfolder(".tests/delfolder") == false, "Failed to delete folder (isfolder = " .. tostring(isfolder(".tests/delfolder")) .. ")")
	end)
	
	test("delfile", {}, function()
		writefile(".tests/delfile.txt", "Hello, world!")
		delfile(".tests/delfile.txt")
		assert(isfile(".tests/delfile.txt") == false, "Failed to delete file (isfile = " .. tostring(isfile(".tests/delfile.txt")) .. ")")
	end)
	
	test("loadfile", {}, function()
		writefile(".tests/loadfile.txt", "return ... + 1")
		assert(assert(loadfile(".tests/loadfile.txt"))(1) == 2, "Failed to load a file with arguments")
		writefile(".tests/loadfile.txt", "f")
		local callback, err = loadfile(".tests/loadfile.txt")
		assert(err and not callback, "Did not return an error message for a compiler error")
	end)
	
	test("dofile", {})
	
	-- Input
	
	test("isrbxactive", {"isgameactive"}, function()
		assert(type(isrbxactive()) == "boolean", "Did not return a boolean value")
	end)
	
	test("mouse1click", {})
	
	test("mouse1press", {})
	
	test("mouse1release", {})
	
	test("mouse2click", {})
	
	test("mouse2press", {})
	
	test("mouse2release", {})
	
	test("mousemoveabs", {})
	
	test("mousemoverel", {})
	
	test("mousescroll", {})
	
	-- Instances
	
	test("fireclickdetector", {}, function()
		local detector = Instance.new("ClickDetector")
		fireclickdetector(detector, 50, "MouseHoverEnter")
	end)
	
	test("getcallbackvalue", {}, function()
		local bindable = Instance.new("BindableFunction")
		local function test()
		end
		bindable.OnInvoke = test
		assert(getcallbackvalue(bindable, "OnInvoke") == test, "Did not return the correct value")
	end)
	
	test("getconnections", {}, function()
		local types = {
			Enabled = "boolean",
			ForeignState = "boolean",
			LuaConnection = "boolean",
			Function = "function",
			Thread = "thread",
			Fire = "function",
			Defer = "function",
			Disconnect = "function",
			Disable = "function",
			Enable = "function",
		}
		local bindable = Instance.new("BindableEvent")
		bindable.Event:Connect(function() end)
		local connection = getconnections(bindable.Event)[1]
		for k, v in pairs(types) do
			assert(connection[k] ~= nil, "Did not return a table with a '" .. k .. "' field")
			assert(type(connection[k]) == v, "Did not return a table with " .. k .. " as a " .. v .. " (got " .. type(connection[k]) .. ")")
		end
	end)
	
	test("getcustomasset", {}, function()
		writefile(".tests/getcustomasset.txt", "success")
		local contentId = getcustomasset(".tests/getcustomasset.txt")
		assert(type(contentId) == "string", "Did not return a string")
		assert(#contentId > 0, "Returned an empty string")
		assert(string.match(contentId, "rbxasset://") == "rbxasset://", "Did not return an rbxasset url")
	end)
	
	test("gethiddenproperty", {}, function()
		local fire = Instance.new("Fire")
		local property, isHidden = gethiddenproperty(fire, "size_xml")
		assert(property == 5, "Did not return the correct value")
		assert(isHidden == true, "Did not return whether the property was hidden")
	end)
	
	test("sethiddenproperty", {}, function()
		local fire = Instance.new("Fire")
		local hidden = sethiddenproperty(fire, "size_xml", 10)
		assert(hidden, "Did not return true for the hidden property")
		assert(gethiddenproperty(fire, "size_xml") == 10, "Did not set the hidden property")
	end)
	
	test("gethui", {}, function()
		assert(typeof(gethui()) == "Instance", "Did not return an Instance")
	end)
	
	test("getinstances", {}, function()
		assert(getinstances()[1]:IsA("Instance"), "The first value is not an Instance")
	end)
	
	test("getnilinstances", {}, function()
		assert(getnilinstances()[1]:IsA("Instance"), "The first value is not an Instance")
		assert(getnilinstances()[1].Parent == nil, "The first value is not parented to nil")
	end)
	
	test("isscriptable", {}, function()
		local fire = Instance.new("Fire")
		assert(isscriptable(fire, "size_xml") == false, "Did not return false for a non-scriptable property (size_xml)")
		assert(isscriptable(fire, "Size") == true, "Did not return true for a scriptable property (Size)")
	end)
	
	test("setscriptable", {}, function()
		local fire = Instance.new("Fire")
		local wasScriptable = setscriptable(fire, "size_xml", true)
		assert(wasScriptable == false, "Did not return false for a non-scriptable property (size_xml)")
		assert(isscriptable(fire, "size_xml") == true, "Did not set the scriptable property")
		fire = Instance.new("Fire")
		assert(isscriptable(fire, "size_xml") == false, "⚠️⚠️ setscriptable persists between unique instances ⚠️⚠️")
	end)
	
	test("setrbxclipboard", {})
	
	-- Metatable
	
	test("getrawmetatable", {}, function()
		local metatable = { __metatable = "Locked!" }
		local object = setmetatable({}, metatable)
		assert(getrawmetatable(object) == metatable, "Did not return the metatable")
	end)
	
	test("hookmetamethod", {}, function()
		local object = setmetatable({}, { __index = newcclosure(function() return false end), __metatable = "Locked!" })
		local ref = hookmetamethod(object, "__index", function() return true end)
		assert(object.test == true, "Failed to hook a metamethod and change the return value")
		assert(ref() == false, "Did not return the original function")
	end)
	
	test("getnamecallmethod", {}, function()
		local method
		local ref
		ref = hookmetamethod(game, "__namecall", function(...)
			if not method then
				method = getnamecallmethod()
			end
			return ref(...)
		end)
		game:GetService("Lighting")
		assert(method == "GetService", "Did not get the correct method (GetService)")
	end)
	
	test("isreadonly", {}, function()
		local object = {}
		table.freeze(object)
		assert(isreadonly(object), "Did not return true for a read-only table")
	end)
	
	test("setrawmetatable", {}, function()
		local object = setmetatable({}, { __index = function() return false end, __metatable = "Locked!" })
		local objectReturned = setrawmetatable(object, { __index = function() return true end })
		assert(object, "Did not return the original object")
		assert(object.test == true, "Failed to change the metatable")
		if objectReturned then
			return objectReturned == object and "Returned the original object" or "Did not return the original object"
		end
	end)
	
	test("setreadonly", {}, function()
		local object = { success = false }
		table.freeze(object)
		setreadonly(object, false)
		object.success = true
		assert(object.success, "Did not allow the table to be modified")
	end)
	
	-- Miscellaneous
	
	test("identifyexecutor", {"getexecutorname"}, function()
		local name, version = identifyexecutor()
		assert(type(name) == "string", "Did not return a string for the name")
		return type(version) == "string" and "Returns version as a string" or "Does not return version"
	end)
	
	test("lz4compress", {}, function()
		local raw = "Hello, world!"
		local compressed = lz4compress(raw)
		assert(type(compressed) == "string", "Compression did not return a string")
		assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
	end)
	
	test("lz4decompress", {}, function()
		local raw = "Hello, world!"
		local compressed = lz4compress(raw)
		assert(type(compressed) == "string", "Compression did not return a string")
		assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
	end)
	
	test("messagebox", {})
	
	test("queue_on_teleport", {"queueonteleport"})
	
	test("request", {"http.request", "http_request"}, function()
		local response = request({
			Url = "https://httpbin.org/user-agent",
			Method = "GET",
		})
		assert(type(response) == "table", "Response must be a table")
		assert(response.StatusCode == 200, "Did not return a 200 status code")
		local data = game:GetService("HttpService"):JSONDecode(response.Body)
		assert(type(data) == "table" and type(data["user-agent"]) == "string", "Did not return a table with a user-agent key")
		return "User-Agent: " .. data["user-agent"]
	end)
	
	test("setclipboard", {"toclipboard"})
	
	test("setfpscap", {}, function()
		local renderStepped = game:GetService("RunService").RenderStepped
		local function step()
			renderStepped:Wait()
			local sum = 0
			for _ = 1, 5 do
				sum += 1 / renderStepped:Wait()
			end
			return math.round(sum / 5)
		end
		setfpscap(60)
		local step60 = step()
		setfpscap(0)
		local step0 = step()
		return step60 .. "fps @60 • " .. step0 .. "fps @0"
	end)
	
	-- Scripts
	
	test("getgc", {}, function()
		local gc = getgc()
		assert(type(gc) == "table", "Did not return a table")
		assert(#gc > 0, "Did not return a table with any values")
	end)
	
	test("getgenv", {}, function()
		getgenv().__TEST_GLOBAL = true
		assert(__TEST_GLOBAL, "Failed to set a global variable")
		getgenv().__TEST_GLOBAL = nil
	end)
	
	test("getloadedmodules", {}, function()
		local modules = getloadedmodules()
		assert(type(modules) == "table", "Did not return a table")
		assert(#modules > 0, "Did not return a table with any values")
		assert(typeof(modules[1]) == "Instance", "First value is not an Instance")
		assert(modules[1]:IsA("ModuleScript"), "First value is not a ModuleScript")
	end)
	
	test("getrenv", {}, function()
		assert(_G ~= getrenv()._G, "The variable _G in the executor is identical to _G in the game")
	end)
	
	test("getrunningscripts", {}, function()
		local scripts = getrunningscripts()
		assert(type(scripts) == "table", "Did not return a table")
		assert(#scripts > 0, "Did not return a table with any values")
		assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
		assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
	end)
	
	test("getscriptbytecode", {"dumpstring"}, function()
		local animate = game:GetService("Players").LocalPlayer.Character.Animate
		local bytecode = getscriptbytecode(animate)
		assert(type(bytecode) == "string", "Did not return a string for Character.Animate (a " .. animate.ClassName .. ")")
	end)
	
	test("getscripthash", {}, function()
		local animate = game:GetService("Players").LocalPlayer.Character.Animate:Clone()
		local hash = getscripthash(animate)
		local source = animate.Source
		animate.Source = "print('Hello, world!')"
		task.defer(function()
			animate.Source = source
		end)
		local newHash = getscripthash(animate)
		assert(hash ~= newHash, "Did not return a different hash for a modified script")
		assert(newHash == getscripthash(animate), "Did not return the same hash for a script with the same source")
	end)
	
	test("getscripts", {}, function()
		local scripts = getscripts()
		assert(type(scripts) == "table", "Did not return a table")
		assert(#scripts > 0, "Did not return a table with any values")
		assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
		assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
	end)
	
	test("getsenv", {}, function()
		local animate = game:GetService("Players").LocalPlayer.Character.Animate
		local env = getsenv(animate)
		assert(type(env) == "table", "Did not return a table for Character.Animate (a " .. animate.ClassName .. ")")
		assert(env.script == animate, "The script global is not identical to Character.Animate")
	end)
	
	test("getthreadidentity", {"getidentity", "getthreadcontext"}, function()
		assert(type(getthreadidentity()) == "number", "Did not return a number")
	end)
	
	test("setthreadidentity", {"setidentity", "setthreadcontext"}, function()
		setthreadidentity(3)
		assert(getthreadidentity() == 3, "Did not set the thread identity")
	end)
	
	-- Drawing
	
	test("Drawing", {})
	
	test("Drawing.new", {}, function()
		local drawing = Drawing.new("Square")
		drawing.Visible = false
		local canDestroy = pcall(function()
			drawing:Destroy()
		end)
		assert(canDestroy, "Drawing:Destroy() should not throw an error")
	end)
	
	test("Drawing.Fonts", {}, function()
		assert(Drawing.Fonts.UI == 0, "Did not return the correct id for UI")
		assert(Drawing.Fonts.System == 1, "Did not return the correct id for System")
		assert(Drawing.Fonts.Plex == 2, "Did not return the correct id for Plex")
		assert(Drawing.Fonts.Monospace == 3, "Did not return the correct id for Monospace")
	end)
	
	test("isrenderobj", {}, function()
		local drawing = Drawing.new("Image")
		drawing.Visible = true
		assert(isrenderobj(drawing) == true, "Did not return true for an Image")
		assert(isrenderobj(newproxy()) == false, "Did not return false for a blank table")
	end)
	
	test("getrenderproperty", {}, function()
		local drawing = Drawing.new("Image")
		drawing.Visible = true
		assert(type(getrenderproperty(drawing, "Visible")) == "boolean", "Did not return a boolean value for Image.Visible")
		local success, result = pcall(function()
			return getrenderproperty(drawing, "Color")
		end)
		if not success or not result then
			return "Image.Color is not supported"
		end
	end)
	
	test("setrenderproperty", {}, function()
		local drawing = Drawing.new("Square")
		drawing.Visible = true
		setrenderproperty(drawing, "Visible", false)
		assert(drawing.Visible == false, "Did not set the value for Square.Visible")
	end)
	
	test("cleardrawcache", {}, function()
		cleardrawcache()
	end)
	
	-- WebSocket
	
	test("WebSocket", {})
	
	test("WebSocket.connect", {}, function()
		local types = {
			Send = "function",
			Close = "function",
			OnMessage = {"table", "userdata"},
			OnClose = {"table", "userdata"},
		}
		local ws = WebSocket.connect("ws://echo.websocket.events")
		assert(type(ws) == "table" or type(ws) == "userdata", "Did not return a table or userdata")
		for k, v in pairs(types) do
			if type(v) == "table" then
				assert(table.find(v, type(ws[k])), "Did not return a " .. table.concat(v, ", ") .. " for " .. k .. " (a " .. type(ws[k]) .. ")")
			else
				assert(type(ws[k]) == v, "Did not return a " .. v .. " for " .. k .. " (a " .. type(ws[k]) .. ")")
			end
		end
		ws:Close()
	end)
end
local function EAEQTWO_fake_script() -- Fake Script: StarterGui.ScreenGui.datac1.LocalScript
    local script = Instance.new("LocalScript")
    script.Name = "LocalScript"
    script.Parent = Converted["_datac1"]
    local req = require
    local require = function(obj)
        local fake = fake_module_scripts[obj]
        if fake then
            return fake()
        end
        return req(obj)
    end

	
	local frame = script.Parent
	local dragging = false
	local dragInput
	local dragStart
	local startPos
	
	-- Function to update the frame's position as it is dragged
	local function update(input)
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
	
	-- When a drag starts
	frame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	-- When dragging is ongoing
	frame.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			dragInput = input
		end
	end)
	
	-- Update frame position while dragging
	game:GetService("UserInputService").InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
	
end

coroutine.wrap(MZCDPW_fake_script)()
coroutine.wrap(FAYDP_fake_script)()
coroutine.wrap(HPDCYS_fake_script)()
coroutine.wrap(NHQUAFU_fake_script)()
coroutine.wrap(XHHTXN_fake_script)()
coroutine.wrap(ETFWBO_fake_script)()
coroutine.wrap(VBQOOJX_fake_script)()
coroutine.wrap(LFLPZE_fake_script)()
coroutine.wrap(WOBKQGO_fake_script)()
coroutine.wrap(NZUF_fake_script)()
coroutine.wrap(MGXAS_fake_script)()
coroutine.wrap(GPNM_fake_script)()
coroutine.wrap(LBXJYD_fake_script)()
coroutine.wrap(OMVFX_fake_script)()
coroutine.wrap(PWHX_fake_script)()
coroutine.wrap(EAEQTWO_fake_script)()
